<!-- Generated by SpecStory -->

# Implement yaw-only acceleration tweak (2025-09-16 17:02Z)

_**User**_

1) Please see below chat with AI.  Would you implement its outlined change (Yaw only), adding the tweak constant to config.js

2) Chat with AI regarding smashing into animation limits when increasing animation speed by dragging slider:

=== ME ====
1) There is a subtle issue that you may(?) not fully appreciate:  While it is true that reducing acceleration increases the time needed to stop, it also (obviously) decreases the available acceleration to do so.  So changing it does not, at least not in an obvious way, improve not smashing into the limits — because the two effects I believe cancel each other out.  To have a real effect, one would need to *separate* the acceleration used to determine stopping distance and that used to actually accelerate.  In other words and for example, if we decreased the acceleration used to calculate the stopping distance, but did *not* decrease the acceleration actually available to change the velocity, *that* would have an affect.

2) I think you have lateMargin backwards:  Making it positive causes *greater* smash, not less.  It would need to be negative to to help with that.  However, lateMargin, for both Pitch and Yaw, has an affect that is too discretized — regardless of its values, its consequence is to change when FSM trigger is met, from happening at frame N to instead happen at frame N +/- i (where N and i are integers).  That is not really what we want.  What do you think about removing lateMargin entirely and instead creating two accelerations, the one calculated by max(time, runway), and the one used for stopping distance, where the only difference between them is a new constant accelerationTweak where accelerationUsedForStopCalculation = accelerationActual*accelerationTweak, where 1.0 for accelerationTweak would make them the same, and we could make slight greater or less than 1.0 (less than 1 to prevent smashing) and where we could use that same design to make this adjustment temporarily/conditionally even greater, if/as necessary, when dragging slider faster.  Note:  If you think tweak should be additive rather than multiplicative, let me know.

What do you think?
========

===== AI =====
You’re thinking about this exactly right: **separate the acceleration used to *decide when to reverse*** from the acceleration we **actually apply** in the reversal plan. That lets us trigger earlier (avoid smashes) **without changing** the planned easing profile.

Below is a **tiny, yaw‑only** edit that does just that. It introduces a second acceleration, `aStop`, used **only** in the predictive inequality (the stop‑distance test). The plan acceleration `aPlan` (what we pass to `initiateReversal`) is left unchanged. This is the smallest possible step and it doesn’t reintroduce the previous failure because we’re not touching the reversal execution or doing per‑frame replans — we only adjust the predictive trigger math.&#x20;

---

## Why this works (quick intuition)

* Predictive reversal currently uses
  `stopDist = vCur² / (2 * aUsed)` and triggers when `stopDist ≥ dOut` (plus tiny epsilons). In code that’s:

  ```js
  const stopDist = (spin.curYawVel * spin.curYawVel) / (2 * Math.max(aUsed, config.YAW_EPS_VEL));
  if (movingOutward && dOut + lateMargin <= stopDist + config.YAW_EPS_ANG) { ... }
  ```

  (Yaw has `lateMargin = 0` already.)&#x20;

* If we **decrease the acceleration used in the stop‑distance formula** (call it `aStop`), `stopDist` **increases**, so the reversal **triggers earlier**. That does *not* change the actual applied easing/accel, because the plan `aPlan` is passed separately to `initiateReversal`. This directly addresses your “two effects cancel” concern: they only cancel if you reduce both the planning accel and the stopping‑distance accel by the same amount; we’re **not** doing that. We reduce only `aStop`.

* Re lateMargin: you’re right — in yaw it’s coded as `0`; in pitch it’s optional and *adds* to the left side of the inequality, which **delays** trigger when positive (so yes, positive makes smashing worse, negative would trigger earlier). Your suggestion to **remove lateMargin and replace it with a continuous factor on the stop‑distance accel** is exactly what we’re doing here.&#x20;

* **Multiplicative vs. additive tweak:** multiplicative is safer (unitless, scales across speeds and ease times). Additive is in rad/s²; it will be too small at high speeds and too large at low speeds.

---

## Step 1 — Yaw‑only: split `aUsed` into `aPlan` vs `aStop` with a tweak (no other behavior changed)

> **What we change:** in the yaw predictive branch we compute the usual `aPlan` (exactly as before), then compute `aStop = aPlan * tweak`. We use `aStop` **only** for the stop‑distance test; we continue to pass `aPlan` to `initiateReversal`.
> **Default tweak:** 0.90 (10% earlier trigger). You can tune 0.95 (gentle) … 0.80 (more cushion). No need to edit `config.js`; we read a missing config as `undefined` and fall back to 0.90.

**File:** `animation-engine.js`
**Where:** `handleYawBounce(...)`, **predictive** branch (“Predictive reversal: symmetric threshold during accel; braking threshold during steady”).
**Approx lines:** \~930–1005.

**EDIT** the block that computes `aUsed`, logs it, computes `stopDist`, and calls `initiateReversal`. Replace with the version below.

**Before (for reference / context, 3 lines above/below):**

```js
    } else if (spin.yawState === 'eYaw_SteadyStateVel' || 
               spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
        // Predictive reversal: symmetric threshold during accel; braking threshold during steady
        const easeSec = Math.max(0, config.DEFAULT_EASE_TIME_MS) / 1000;
        if (easeSec > 0 && spin.curYawVel !== 0) {
            const velSign = Math.sign(spin.curYawVel);
            const dOut = computeOutwardRunway(spin, s, 'yaw');
            const movingOutward = velSign !== 0 && Math.sign(dAz) === velSign;

            const aUsed = (spin.yawState === 'eYaw_IncreaseVelToSteadyState')
                ? computeAccelMax(easeSec, Math.abs(spin.yawSpeed), dOut / 2)
                : computeAccelMax(easeSec, spin.curYawVel, dOut);

            diagSampledLog('yaw-predictive-aUsed', () => {
                if (spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
                    const aTimeT = (Math.abs(spin.yawSpeed)/Math.max(easeSec,1e-6)).toFixed(6);
                    const aRunwaySym = ((Math.abs(spin.yawSpeed)*Math.abs(spin.yawSpeed))/Math.max(dOut,1e-9)).toFixed(6);
                    console.log(`[DIAG] YAW aUsed(predictive SYM) dOut=${dOut.toFixed(4)} vTarget=${Math.abs(spin.yawSpeed).toFixed(4)} aTimeT=${aTimeT} aRunwaySym=${aRunwaySym} aUse=${aUsed.toFixed(6)} state=${spin.yawState}`);
                } else {
                    console.log(`[DIAG] YAW aUsed(predictive BRAKE) dOut=${dOut.toFixed(4)} vCur=${spin.curYawVel.toFixed(4)} aTime=${(Math.abs(spin.curYawVel)/Math.max(easeSec,1e-6)).toFixed(6)} aRunway=${((Math.abs(spin.curYawVel)*Math.abs(spin.curYawVel))/(2*Math.max(dOut,1e-9))).toFixed(6)} aUse=${aUsed.toFixed(6)} state=${spin.yawState}`);
                }
            });

            const lateMargin = 0; // No yaw late margin by default (kept for parity with pitch option)
            const stopDist = (spin.curYawVel * spin.curYawVel) / (2 * Math.max(aUsed, config.YAW_EPS_VEL));
            if (movingOutward && dOut + lateMargin <= stopDist + config.YAW_EPS_ANG) {
                diagSampledLog('yaw-bounce-init-reversal', () => {
                    console.log(`[DIAG] YAW BOUNCE Initiating reversal: dAz=${dAz.toFixed(4)}, runway=${dOut.toFixed(4)}, stopDist=${stopDist.toFixed(4)}, aUsed=${aUsed.toFixed(6)}, state=${spin.yawState}`);
                });
                if (spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
                    // Preserve current outward velocity instead of jumping to full steady
                    spin.yawTransitionVel = spin.curYawVel;
                    spin.yawA = 0;
                    spin.yawState = 'eYaw_SteadyStateVel';
                }
                initiateReversal(spin, 'yaw', aUsed);
            }
        }
    }
```

**After (edit to compute `aPlan` and `aStop = aPlan * tweak`; use `aStop` only for stopDist; still pass `aPlan` to `initiateReversal`)**

```diff
     } else if (spin.yawState === 'eYaw_SteadyStateVel' || 
                spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
         // Predictive reversal: symmetric threshold during accel; braking threshold during steady
         const easeSec = Math.max(0, config.DEFAULT_EASE_TIME_MS) / 1000;
         if (easeSec > 0 && spin.curYawVel !== 0) {
             const velSign = Math.sign(spin.curYawVel);
             const dOut = computeOutwardRunway(spin, s, 'yaw');
             const movingOutward = velSign !== 0 && Math.sign(dAz) === velSign;
-
-            const aUsed = (spin.yawState === 'eYaw_IncreaseVelToSteadyState')
-                ? computeAccelMax(easeSec, Math.abs(spin.yawSpeed), dOut / 2)
-                : computeAccelMax(easeSec, spin.curYawVel, dOut);
+            // aPlan = acceleration magnitude we'd plan the reversal with (unchanged behavior)
+            const aPlan = (spin.yawState === 'eYaw_IncreaseVelToSteadyState')
+                ? computeAccelMax(easeSec, Math.abs(spin.yawSpeed), dOut / 2)
+                : computeAccelMax(easeSec, spin.curYawVel, dOut);
+            // aStop = slightly reduced accel used ONLY for stop-distance math, to trigger earlier
+            const tweak = (config.YAW_PREDICTIVE_ACCEL_TWEAK ?? 0.90); // < 1.0 → earlier
+            const aStop = aPlan * tweak;
 
             diagSampledLog('yaw-predictive-aUsed', () => {
-                if (spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
-                    const aTimeT = (Math.abs(spin.yawSpeed)/Math.max(easeSec,1e-6)).toFixed(6);
-                    const aRunwaySym = ((Math.abs(spin.yawSpeed)*Math.abs(spin.yawSpeed))/Math.max(dOut,1e-9)).toFixed(6);
-                    console.log(`[DIAG] YAW aUsed(predictive SYM) dOut=${dOut.toFixed(4)} vTarget=${Math.abs(spin.yawSpeed).toFixed(4)} aTimeT=${aTimeT} aRunwaySym=${aRunwaySym} aUse=${aUsed.toFixed(6)} state=${spin.yawState}`);
-                } else {
-                    console.log(`[DIAG] YAW aUsed(predictive BRAKE) dOut=${dOut.toFixed(4)} vCur=${spin.curYawVel.toFixed(4)} aTime=${(Math.abs(spin.curYawVel)/Math.max(easeSec,1e-6)).toFixed(6)} aRunway=${((Math.abs(spin.curYawVel)*Math.abs(spin.curYawVel))/(2*Math.max(dOut,1e-9))).toFixed(6)} aUse=${aUsed.toFixed(6)} state=${spin.yawState}`);
-                }
+                const mode = (spin.yawState === 'eYaw_IncreaseVelToSteadyState') ? 'SYM' : 'BRAKE';
+                console.log(`[DIAG] YAW aPlan(${mode}) dOut=${dOut.toFixed(4)} `
+                  + `aPlan=${aPlan.toFixed(6)} tweak=${tweak.toFixed(3)} aStop=${aStop.toFixed(6)} `
+                  + `vCur=${spin.curYawVel.toFixed(4)} state=${spin.yawState}`);
             });
 
-            const lateMargin = 0; // No yaw late margin by default (kept for parity with pitch option)
-            const stopDist = (spin.curYawVel * spin.curYawVel) / (2 * Math.max(aUsed, config.YAW_EPS_VEL));
+            const lateMargin = 0; // keep yaw late margin off; we bias earlier via aStop
+            const stopDist = (spin.curYawVel * spin.curYawVel) / (2 * Math.max(aStop, config.YAW_EPS_VEL));
             if (movingOutward && dOut + lateMargin <= stopDist + config.YAW_EPS_ANG) {
                 diagSampledLog('yaw-bounce-init-reversal', () => {
-                    console.log(`[DIAG] YAW BOUNCE Initiating reversal: dAz=${dAz.toFixed(4)}, runway=${dOut.toFixed(4)}, stopDist=${stopDist.toFixed(4)}, aUsed=${aUsed.toFixed(6)}, state=${spin.yawState}`);
+                    console.log(`[DIAG] YAW BOUNCE Initiating reversal: dAz=${dAz.toFixed(4)}, runway=${dOut.toFixed(4)}, `
+                      + `stopDist=${stopDist.toFixed(4)}, aPlan=${aPlan.toFixed(6)}, aStop=${aStop.toFixed(6)}, state=${spin.yawState}`);
                 });
                 if (spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
                     // Preserve current outward velocity instead of jumping to full steady
                     spin.yawTransitionVel = spin.curYawVel;
                     spin.yawA = 0;
                     spin.yawState = 'eYaw_SteadyStateVel';
                 }
-                initiateReversal(spin, 'yaw', aUsed);
+                // Use the original plan accel; only the trigger timing used aStop
+                initiateReversal(spin, 'yaw', aPlan);
             }
         }
     }
```

**What to test (after Step 1):**

1. **No slider motion at all**: approaches to yaw limits should **no longer smash**; reversals should occur slightly earlier than before (watch DIAG message showing `aPlan` vs `aStop`).
2. **Click to a fast value**: still **instant** (unchanged steady-state behavior).
3. **Drag to faster** while accelerating: predictive should still trigger smoothly; because planning accel is unchanged (`aPlan`), easing on reversal remains as before; only the trigger time was made earlier/smoother.

> If you want the effect slightly stronger/weaker, tune `config.YAW_PREDICTIVE_ACCEL_TWEAK` to e.g. `0.95` or `0.85` (we default to `0.90` if the config export is missing).&#x20;

---

## Notes on your two questions

* **“Should we use `min(...)` or `max(...)` between braking and symmetric forms?”**
  Smaller `a` ⇒ larger `stopDist` ⇒ earlier reversal ⇒ **safer**. So if you ever combine two alternatives for the *stop‑distance* side, `min` is safer; `max` pushes the trigger later (risking a slam). In the code above we didn’t change your current choice (symmetric in accel, braking in steady); we merely tweaked the *stop‑side* by a small multiplicative factor.&#x20;

* **On lateMargin**
  Your observation is correct for the inequality in code: making `lateMargin` **positive** delays the trigger (worse), negative makes it earlier (safer), but it’s still **frame‑quantized**. The `aStop` tweak is **continuous** and avoids that “N vs N±1 frames” stepping. (Yaw already uses `lateMargin = 0`; pitch has an optional dt‑scaled margin.)&#x20;

---

## Optional Step 2 (only if needed later): temporary extra cushion while **dragging**

If you later want **even earlier** triggers only for \~100–200 ms after the user starts *dragging* (not clicking), we can add a tiny engine‑local “recent yawSpeed change” detector and apply a stronger `tweak` only while the flag is true. This involves adding two small fields to the state and a 5‑line gate at the top of `processYawFSM`. I’ve left it out for now to keep Step 1 minimal.

---

If anything in the diff isn’t clear or doesn’t match your file around those lines, tell me what you see and I’ll adjust the patch around your exact context. The only moving parts we changed are inside **`handleYawBounce`**; everything else (including reversal planning and easing) is untouched.




---

_**Assistant**_

<think><details><summary>Thought Process</summary>Let me understand what the user wants:

1. They have had a chat with an AI about fixing animation issues when dragging sliders to increase animation speed
2. The AI suggested separating the acceleration used for calculating stopping distance from the actual acceleration used for the animation 
3. The AI provided a specific code change that:
   - Creates two accelerations: `aPlan` (for actual animation) and `aStop` (for stop distance calculation)
   - Uses a multiplicative tweak factor to make `aStop` smaller than `aPlan`, causing earlier reversals
   - Suggests adding a `YAW_PREDICTIVE_ACCEL_TWEAK` constant to config.js

The user wants me to:
1. Implement this change (Yaw only as outlined)
2. Add the tweak constant to config.js

Let me first examine the current animation-engine.js file to see the existing code structure, then implement the changes.</details></think>

---

I'll implement the outlined change to separate the planning acceleration from the stop-distance acceleration for yaw animations, and add the tweak constant to config.js. Let me first examine the current code structure.

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>I can see the current code structure. Now let me see the rest of the yaw bounce handling to get the complete picture:</details></think>

---

Read file: undefined

---

<think><details><summary>Thought Process</summary>Perfect! Now I can see the exact structure. I need to:

1. First add the new constant `YAW_PREDICTIVE_ACCEL_TWEAK` to config.js
2. Then modify the yaw predictive reversal code (lines ~1005-1031) to implement the change

Let me create a todo list and implement these changes.</details></think>

---

## Todo List

- [-] Add YAW_PREDICTIVE_ACCEL_TWEAK constant to config.js with default 0.90
- [ ] Modify yaw predictive reversal logic to separate aPlan vs aStop accelerations

---

<think><details><summary>Thought Process</summary>Now let me implement the changes. First I'll add the constant to config.js, then modify the animation-engine.js code.</details></think>

---

<details><summary>Edit file: js/config.js</summary>

undefined

**Chunk 1**
Lines added: 4, lines removed: 2

```diff
@@ -273,4 +274,6 @@
  // Predictive reversal late-trigger margin (Pitch only)
  export const ENABLE_PITCH_LATE_MARGIN = false;      // If true, delay steady-state predictive by ~v*dt to test slight overshoot.  (Looks much worse than having stop short a bit early at high speeds.)
- export const ENABLE_PITCH_LATE_MARGIN = false;      // If true, delay steady-state predictive by ~v*dt to test slight overshoot.  (Looks much worse than having stop short a bit early at high speeds.)
- export const PITCH_PREDICTIVE_LATE_MARGIN_MULT = 1; // Multiplier on v*dt margin when ENABLE_PITCH_LATE_MARGIN is true.  (Small values are of no affect — issue is discretized by animation frames.)
+ export const PITCH_PREDICTIVE_LATE_MARGIN_MULT = 1; // Multiplier on v*dt margin when ENABLE_PITCH_LATE_MARGIN is true.  (Small values are of no affect — issue is discretized by animation frames.)
+ 
+ // Yaw predictive reversal acceleration tweaking
+ export const YAW_PREDICTIVE_ACCEL_TWEAK = 0.90;     // Multiplier for stop-distance accel (< 1.0 triggers earlier reversals, preventing limit smashing when dragging sliders)
```

</details>

---

<think><details><summary>Thought Process</summary>Good! Now let me update the todo status and implement the yaw separation logic in animation-engine.js.</details></think>

---

## Todo List

- [x] Add YAW_PREDICTIVE_ACCEL_TWEAK constant to config.js with default 0.90
- [-] Modify yaw predictive reversal logic to separate aPlan vs aStop accelerations

---

<details><summary>Edit file: js/animation/animation-engine.js</summary>

undefined

**Chunk 1**
Lines added: 13, lines removed: 11

```diff
@@ -1003,23 +1003,25 @@
              const movingOutward = velSign !== 0 && Math.sign(dAz) === velSign;
  
-             const aUsed = (spin.yawState === 'eYaw_IncreaseVelToSteadyState')
+             // aPlan = acceleration magnitude we'd plan the reversal with (unchanged behavior)
+             const aPlan = (spin.yawState === 'eYaw_IncreaseVelToSteadyState')
                  ? computeAccelMax(easeSec, Math.abs(spin.yawSpeed), dOut / 2)
                  : computeAccelMax(easeSec, spin.curYawVel, dOut);
+             // aStop = slightly reduced accel used ONLY for stop-distance math, to trigger earlier
+             const tweak = (config.YAW_PREDICTIVE_ACCEL_TWEAK ?? 0.90); // < 1.0 → earlier
+             const aStop = aPlan * tweak;
  
              diagSampledLog('yaw-predictive-aUsed', () => {
-                 if (spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
-                     const aTimeT = (Math.abs(spin.yawSpeed)/Math.max(easeSec,1e-6)).toFixed(6);
-                     const aRunwaySym = ((Math.abs(spin.yawSpeed)*Math.abs(spin.yawSpeed))/Math.max(dOut,1e-9)).toFixed(6);
-                     console.log(`[DIAG] YAW aUsed(predictive SYM) dOut=${dOut.toFixed(4)} vTarget=${Math.abs(spin.yawSpeed).toFixed(4)} aTimeT=${aTimeT} aRunwaySym=${aRunwaySym} aUse=${aUsed.toFixed(6)} state=${spin.yawState}`);
-                 } else {
-                     console.log(`[DIAG] YAW aUsed(predictive BRAKE) dOut=${dOut.toFixed(4)} vCur=${spin.curYawVel.toFixed(4)} aTime=${(Math.abs(spin.curYawVel)/Math.max(easeSec,1e-6)).toFixed(6)} aRunway=${((Math.abs(spin.curYawVel)*Math.abs(spin.curYawVel))/(2*Math.max(dOut,1e-9))).toFixed(6)} aUse=${aUsed.toFixed(6)} state=${spin.yawState}`);
-                 }
+                 const mode = (spin.yawState === 'eYaw_IncreaseVelToSteadyState') ? 'SYM' : 'BRAKE';
+                 console.log(`[DIAG] YAW aPlan(${mode}) dOut=${dOut.toFixed(4)} `
+                   + `aPlan=${aPlan.toFixed(6)} tweak=${tweak.toFixed(3)} aStop=${aStop.toFixed(6)} `
+                   + `vCur=${spin.curYawVel.toFixed(4)} state=${spin.yawState}`);
              });
  
-             const lateMargin = 0; // No yaw late margin by default (kept for parity with pitch option)
-             const stopDist = (spin.curYawVel * spin.curYawVel) / (2 * Math.max(aUsed, config.YAW_EPS_VEL));
+             const lateMargin = 0; // keep yaw late margin off; we bias earlier via aStop
+             const stopDist = (spin.curYawVel * spin.curYawVel) / (2 * Math.max(aStop, config.YAW_EPS_VEL));
              if (movingOutward && dOut + lateMargin <= stopDist + config.YAW_EPS_ANG) {
                  diagSampledLog('yaw-bounce-init-reversal', () => {
-                     console.log(`[DIAG] YAW BOUNCE Initiating reversal: dAz=${dAz.toFixed(4)}, runway=${dOut.toFixed(4)}, stopDist=${stopDist.toFixed(4)}, aUsed=${aUsed.toFixed(6)}, state=${spin.yawState}`);
+                     console.log(`[DIAG] YAW BOUNCE Initiating reversal: dAz=${dAz.toFixed(4)}, runway=${dOut.toFixed(4)}, `
+                       + `stopDist=${stopDist.toFixed(4)}, aPlan=${aPlan.toFixed(6)}, aStop=${aStop.toFixed(6)}, state=${spin.yawState}`);
                  });
                  if (spin.yawState === 'eYaw_IncreaseVelToSteadyState') {
```

**Chunk 2**
Lines added: 2, lines removed: 1

```diff
@@ -1029,5 +1031,6 @@
                      spin.yawState = 'eYaw_SteadyStateVel';
                  }
-                 initiateReversal(spin, 'yaw', aUsed);
+                 // Use the original plan accel; only the trigger timing used aStop
+                 initiateReversal(spin, 'yaw', aPlan);
              }
          }
```

</details>

---

<think><details><summary>Thought Process</summary>Excellent! Now let me complete the todo and check for linter errors.</details></think>

---

## Todo List

- [x] Add YAW_PREDICTIVE_ACCEL_TWEAK constant to config.js with default 0.90
- [x] Modify yaw predictive reversal logic to separate aPlan vs aStop accelerations

---



---

<think><details><summary>Thought Process</summary>Perfect! The implementation is complete with no linter errors. Let me provide a summary of what I've implemented.</details></think>

---

Perfect! I've successfully implemented the outlined changes for the yaw-only acceleration separation fix. Here's what was done:

## Summary of Changes

### 1. Added Configuration Constant
**File:** `js/config.js`
- Added `YAW_PREDICTIVE_ACCEL_TWEAK = 0.90` constant
- This multiplier reduces the acceleration used for stop-distance calculations (< 1.0 triggers earlier reversals)
- Default value of 0.90 provides 10% earlier triggering to prevent limit smashing when dragging sliders

### 2. Modified Yaw Predictive Reversal Logic
**File:** `js/animation/animation-engine.js` (lines ~1005-1034)
- **Separated accelerations**: Split the single `aUsed` into two distinct values:
  - `aPlan`: Original acceleration for planning the actual reversal (unchanged behavior)
  - `aStop`: Reduced acceleration (aPlan × tweak) used only for stop-distance calculations
- **Updated stop-distance calculation**: Now uses `aStop` instead of the original `aUsed`
- **Preserved reversal planning**: `initiateReversal()` still receives the original `aPlan`, so easing behavior remains unchanged
- **Enhanced diagnostics**: Updated logging to show both `aPlan` and `aStop` values for debugging

## Key Benefits

1. **Prevents limit smashing**: Earlier triggers when dragging sliders to increase animation speed
2. **Non-disruptive**: Only affects trigger timing; actual animation easing remains unchanged
3. **Continuous adjustment**: Unlike the previous frame-quantized `lateMargin`, this provides smooth, continuous adjustment
4. **Tunable**: You can adjust the `YAW_PREDICTIVE_ACCEL_TWEAK` value (0.95 for gentler, 0.85 for more aggressive cushioning)

## Testing Recommendations

1. **No slider motion**: Should see slightly earlier yaw limit reversals (no more smashing)
2. **Click to fast values**: Instant behavior should remain unchanged  
3. **Drag to faster speeds**: Predictive reversals should trigger smoothly without hitting limits
4. **Diagnostic logs**: Watch for the new log format showing both `aPlan` and `aStop` values

The implementation follows the AI's suggestion exactly - separating the two accelerations so the "two effects don't cancel each other out" and providing a multiplicative tweak that can be fine-tuned as needed.

---

